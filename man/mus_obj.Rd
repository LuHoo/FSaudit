% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/states.R
\name{mus_obj}
\alias{mus_obj}
\title{MUS state object.}
\usage{
mus_obj(...)
}
\arguments{
\item{...}{Arguments passed to or from other methods.}
}
\value{
The \code{mus_obj} is updated at every single stage in the sampling
  procedure. When the \code{bv} argument is assigned, the \code{popn} and
  \code{popBv} arguments are calculated. The \code{size} method requires
  input of \code{pm} and calculates the sample size \code{n} argument. The
  \code{significant} method calculates the \code{popSign} and
  \code{signItems} arguments, and updates the values of \code{popn}
  \code{popBv}. The \code{select} method fills the \code{sample} argument.
  The \code{evaluate} method fills the \code{results} argument.
}
\description{
Monetary Unit Sample state object. It contains information
  pertaining to the sample, and it is filled in consecutive stages either by
  the user or by a method applied to the object.
}
\details{
A sampling procedure consists of several stages. Some of the stages
  require the data from earlier stages. The state object records such inputs
  and provides them to later methods as required. The benefit is that these
  inputs do not have to be provided by the user repeatedly, but are obtained
  form the recorded value in the object.

  The typical workflow for an MUS sampling procedure is: \enumerate{ \item
  \code{split_population} Splits population into positive, zero-value and
  negative values. \item \code{size} Calculates the sample size. \item
  \code{significant}Removes individually significant items from the sampling
  frame. \item \code{select} Selects the sample. \item \code{evaluate}
  Evaluates the sample. \item \code{extend} Calculates incremental sample
  size, and if this is greater than zero extends the sample. }
}
\examples{
split <- split_population(inventoryData$item, inventoryData$bv)
myMusObject <- mus_obj(id = split$pos_bv$item,
                       bv = split$pos_bv$bv)
myMusObject <- size(myMusObject,
                    pm = 100000)
myMusObject <- significant(myMusObject)
myMusObject <- select(myMusObject,
                      seed = 20201209)
true_values <- inventoryData[match(myMusObject$sample$item,
                                   inventoryData$item),
                             c("item", "av")]
myMusObject <- evaluate(myMusObject, av = true_values$av)

}
